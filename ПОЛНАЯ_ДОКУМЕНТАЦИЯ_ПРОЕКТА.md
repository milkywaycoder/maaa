# ПОЛНАЯ ДОКУМЕНТАЦИЯ ПРОЕКТА SKEETINJECTOR
## Комплексная система инжекта DLL с многоуровневой защитой

---

## ОГЛАВЛЕНИЕ

1. [Общая архитектура проекта](#общая-архитектура-проекта)
2. [Система защиты DLL](#система-защиты-dll)
3. [Механизмы инжекта](#механизмы-инжекта)
4. [Антидамп защита](#антидамп-защита)
5. [Защита Entry Point](#защита-entry-point)
6. [Система безопасности](#система-безопасности)
7. [Шифрование и обфускация](#шифрование-и-обфускация)
8. [Сетевая безопасность](#сетевая-безопасность)
9. [Оптимизация и производительность](#оптимизация-и-производительность)
10. [Совместимость с VMProtect](#совместимость-с-vmprotect)

---

## ОБЩАЯ АРХИТЕКТУРА ПРОЕКТА

### Структура проекта

Проект состоит из двух основных компонентов:

#### 1. **skeetinjector.exe** (Инжектор)
- Основное приложение для инжекта DLL в целевой процесс
- Управление загрузкой и шифрованием DLL
- Система безопасности и проверок
- Интеграция с Firebase для авторизации

#### 2. **gamesense_cs2.dll** (Инжектируемая DLL)
- Целевая DLL для инжекта в cs2.exe
- Система защиты от дампа и анализа
- Overlay интерфейс
- Проверки безопасности в реальном времени

### Модульная архитектура

```
skeetinjector/
├── core/           - Базовые модули (winapi, security, app)
├── inject/         - Модули инжекта (manual map, load library)
├── security/       - Система защиты (антидамп, антипатч, шифрование)
├── network/        - Сетевая безопасность (Firebase, шифрование трафика)
├── data/           - Управление данными (user, product)
└── utils/          - Вспомогательные утилиты (logger, music player)

dllfile/
├── security/       - Защита DLL (антидамп, токен валидация, HWID)
├── network/        - Сетевое взаимодействие (Firebase)
├── menu/           - Overlay интерфейс
└── utils/          - Утилиты DLL
```

---

## СИСТЕМА ЗАЩИТЫ DLL

### 1. Антидамп защита (Anti-Dump Protection)

#### Принцип работы

Антидамп защита предотвращает создание дампов DLL из памяти процесса. Используется несколько техник:

#### 1.1. Инъекция опкодов 0x0F 1A / 0x0F 1B

**Механизм:**
- Опкоды `0x0F 1A` и `0x0F 1B` - это недокументированные инструкции x86/x64
- При попытке дампа эти опкоды вызывают исключения
- Дамперы не могут корректно обработать эти инструкции

**Реализация:**
```cpp
void InjectAntiDumpOps() {
    // Размещаем опкоды в памяти
    BYTE opcodes[] = {0x0F, 0x1A, 0x00, 0x0F, 0x1B, 0x00};
    // Инъекция в критичные места кода
}
```

**Функции:**
- `InjectAntiDumpOps()` - основная инъекция опкодов
- `AntiDumpNOP1()` - `AntiDumpNOP6()` - множественные точки инъекции
- Размещение в разных секциях DLL для максимальной защиты

#### 1.2. Защита секций DLL

**Методы защиты:**

1. **Шифрование секций в памяти:**
   - Секции шифруются после загрузки
   - Расшифровка происходит только при необходимости
   - Постоянная ротация ключей шифрования

2. **Обфускация памяти:**
   - Перемешивание данных в памяти
   - Ложные структуры данных
   - Защита от анализа памяти

3. **Скрамблинг кода:**
   - Перемешивание инструкций
   - Ложные ветки кода
   - Защита от статического анализа

**Функции:**
```cpp
void AntiDumpSectionEncryption();  // Шифрование секций
void AntiDumpMemoryObfuscation();  // Обфускация памяти
void AntiDumpCodeScrambling();      // Скрамблинг кода
void EncryptDLLSections();         // Шифрование
void DecryptDLLSections();         // Расшифровка
void ProtectModuleMemory();        // Защита модуля
```

#### 1.3. Проверка целостности

**Механизм:**
- Постоянная проверка целостности кода
- Верификация контрольных сумм
- Обнаружение модификаций в памяти

**Реализация:**
```cpp
void VerifyIntegrity() {
    // Проверка контрольных сумм секций
    // Обнаружение патчей в памяти
    // Верификация критичных функций
}
```

#### 1.4. Рассеивание кода (Code Scattering)

**Принцип:**
- Код разбивается на фрагменты
- Фрагменты размещаются в разных местах памяти
- Сборка происходит динамически при выполнении

**Преимущества:**
- Невозможность полного дампа
- Защита от статического анализа
- Усложнение реверс-инжиниринга

### 2. Защита Entry Point

#### 2.1. Обфускация DllMain

**Механизм:**
- Оригинальная функция `DllMain` переименована в `DllMain_Protected`
- Добавлена арифметическая обфускация
- Отключена оптимизация компилятора для защиты

**Реализация:**
```cpp
#pragma optimize("", off)
#pragma runtime_checks("", off)
BOOL WINAPI DllMain_Protected(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    // Обфускация через арифметические операции
    volatile DWORD dummy = (DWORD)hModule ^ 0xDEADBEEF;
    dummy = dummy * 0x12345678;
    
    // Минимальная инициализация
    g_hInstance = hModule;
    DisableThreadLibraryCalls(hModule);
    
    // Создание потока для полной инициализации
    CreateThread(NULL, 0, Initialize, NULL, 0, NULL);
    return TRUE;
}

// Экспорт с оригинальным именем
extern "C" BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    return DllMain_Protected(hModule, ul_reason_for_call, lpReserved);
}
```

**Защита:**
- Усложняет поиск точки входа в дампе
- Защита от анализа entry point
- Обфускация критичных операций

#### 2.2. Минимальная инициализация в DllMain

**Принцип:**
- В `DllMain` выполняется только критичная инициализация
- Все сложные операции переносятся в отдельный поток
- Избежание блокировок и дедлоков

**Безопасные операции в DllMain:**
- Сохранение handle модуля
- Отключение уведомлений потоков
- Создание потока инициализации

**Запрещенные операции в DllMain:**
- Работа с реестром
- Файловые операции
- Сетевые запросы
- Сложные проверки безопасности

### 3. Защита от статического анализа

#### 3.1. Обфускация строк

**Механизм:**
- Все строки шифруются XOR шифрованием
- Расшифровка происходит только при использовании
- Динамическая генерация строк

**Реализация:**
```cpp
namespace StringXor {
    std::string decrypt(const std::string& encrypted, int key);
    std::string encrypt(const std::string& plain, int key);
}
```

#### 3.2. Динамическая загрузка API

**Принцип:**
- Критичные API загружаются динамически
- Использование `GetProcAddress` вместо прямых вызовов
- Защита от хуков API

### 4. Защита токенов и авторизации

#### 4.1. Хранение токенов

**Механизм:**
- Токены хранятся в реестре в зашифрованном виде
- Использование сложного шифрования
- Проверка целостности токена

**Структура токена:**
- Username (зашифрован)
- HWID (зашифрован)
- Timestamp
- Подпись для проверки целостности

#### 4.2. Валидация токена

**Проверки:**
1. Проверка формата токена
2. Проверка подписи
3. Проверка срока действия
4. Проверка HWID
5. Проверка whitelist
6. Проверка бана

**Реализация:**
```cpp
namespace TokenValidator {
    bool checkTokenOnLoad();
    TokenData getTokenData();
    bool validateToken(const std::string& token);
}
```

### 5. HWID защита

#### 5.1. Генерация HWID

**Компоненты:**
- CPU ID
- Материнская плата (Serial Number)
- MAC адрес сетевой карты
- Volume Serial Number диска
- Идентификатор Windows

**Алгоритм:**
```cpp
namespace HWID {
    std::string generate();
    std::string get();
    bool verify(const std::string& username);
}
```

#### 5.2. Проверка HWID

**Механизм:**
- HWID генерируется при первом запуске
- Сохраняется в токене
- Проверяется при каждой загрузке DLL
- Несоответствие → краш процесса

---

## МЕХАНИЗМЫ ИНЖЕКТА

### 1. Manual Map V2 (Основной метод)

#### 1.1. Принцип работы

Manual Map - это метод инжекта DLL без использования `LoadLibrary`. DLL вручную маппится в память целевого процесса.

**Преимущества:**
- Не оставляет следов в PEB (Process Environment Block)
- Невидим для большинства антивирусов
- Не виден в списке загруженных модулей
- Полный контроль над процессом загрузки

**Недостатки:**
- Сложность реализации
- Необходимость ручной обработки релокаций и импортов
- Потенциальные проблемы с TLS callbacks

#### 1.2. Процесс инжекта

**Этапы:**

1. **Чтение DLL из файла:**
   ```cpp
   // Открытие файла
   HANDLE hFile = CreateFileA(dllPath.c_str(), GENERIC_READ, FILE_SHARE_READ, 
                              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   
   // Чтение в память
   DWORD fileSize = GetFileSize(hFile, NULL);
   std::vector<BYTE> dllData(fileSize);
   ReadFile(hFile, dllData.data(), fileSize, &bytesRead, NULL);
   ```

2. **Парсинг PE заголовков:**
   ```cpp
   IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)dllData.data();
   IMAGE_NT_HEADERS* pNtHeader = (IMAGE_NT_HEADERS*)(dllData.data() + pDosHeader->e_lfanew);
   
   // Проверка валидности
   if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) return false;
   if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) return false;
   ```

3. **Выделение памяти в целевом процессе:**
   ```cpp
   BYTE* pTargetBase = (BYTE*)VirtualAllocEx(hProc, NULL, 
                                             pNtHeader->OptionalHeader.SizeOfImage,
                                             MEM_COMMIT | MEM_RESERVE, 
                                             PAGE_EXECUTE_READWRITE);
   ```

4. **Копирование заголовков:**
   ```cpp
   WriteProcessMemory(hProc, pTargetBase, dllData.data(), 0x1000, &written);
   ```

5. **Копирование секций:**
   ```cpp
   IMAGE_SECTION_HEADER* pSection = IMAGE_FIRST_SECTION(pNtHeader);
   for (UINT i = 0; i < pNtHeader->FileHeader.NumberOfSections; i++, pSection++) {
       BYTE* src = dllData.data() + pSection->PointerToRawData;
       BYTE* dst = pTargetBase + pSection->VirtualAddress;
       WriteProcessMemory(hProc, dst, src, pSection->SizeOfRawData, &written);
   }
   ```

6. **Подготовка данных для shellcode:**
   ```cpp
   MANUAL_MAPPING_DATA data;
   data.pbase = pTargetBase;
   data.pLoadLibraryA = (f_LoadLibraryA)GetProcAddress(GetModuleHandleA("kernel32.dll"), "LoadLibraryA");
   data.pGetProcAddress = (f_GetProcAddress)GetProcAddress(GetModuleHandleA("kernel32.dll"), "GetProcAddress");
   data.pRtlAddFunctionTable = (f_RtlAddFunctionTable)GetProcAddress(GetModuleHandleA("ntdll.dll"), "RtlAddFunctionTable");
   data.fdwReasonParam = DLL_PROCESS_ATTACH;
   data.reservedParam = 0;
   data.SEHSupport = true;
   ```

7. **Выделение памяти для shellcode:**
   ```cpp
   void* pShellcode = VirtualAllocEx(hProc, NULL, 0x1000, 
                                     MEM_COMMIT | MEM_RESERVE, 
                                     PAGE_EXECUTE_READWRITE);
   WriteProcessMemory(hProc, pShellcode, Shellcode, shellcodeSize, &written);
   ```

8. **Создание удаленного потока:**
   ```cpp
   // Использование NtCreateThreadEx для большей скрытности
   typedef NTSTATUS (WINAPI* pNtCreateThreadEx)(...);
   pNtCreateThreadEx NtCreateThreadEx = (pNtCreateThreadEx)GetProcAddress(
       GetModuleHandleA("ntdll.dll"), "NtCreateThreadEx");
   
   HANDLE hThread = NULL;
   NtCreateThreadEx(&hThread, 0x1FFFFF, NULL, hProc, 
                    (LPTHREAD_START_ROUTINE)pShellcode, 
                    MappingDataAlloc, 0, NULL, NULL, NULL, NULL);
   ```

9. **Ожидание выполнения:**
   ```cpp
   HMODULE hCheck = NULL;
   int waitCount = 0;
   while (waitCount < 500) { // 5 секунд максимум
       ReadProcessMemory(hProc, MappingDataAlloc, &data, sizeof(data), &read);
       if (data.hMod && data.hMod != (HMODULE)0x404040) {
           hCheck = data.hMod;
           break;
       }
       Sleep(10);
       waitCount++;
   }
   ```

10. **Очистка памяти:**
    ```cpp
    // Агрессивная очистка заголовков PE, shellcode и mapping data
    // 5 проходов с разными паттернами (0x00, 0xFF, 0xAA, 0x55)
    for (int pass = 0; pass < 5; pass++) {
        BYTE pattern = /* выбранный паттерн */;
        WriteProcessMemory(hProc, pTargetBase, emptyBuffer, 0x1000, &erased);
        WriteProcessMemory(hProc, pShellcode, emptyBuffer, shellcodeSize, &erased);
        WriteProcessMemory(hProc, MappingDataAlloc, emptyBuffer, sizeof(data), &erased);
    }
    ```

#### 1.3. Shellcode функция

**Назначение:**
Shellcode выполняется в контексте целевого процесса и выполняет:
- Релокации (relocations)
- Разрешение импортов (imports)
- TLS callbacks
- Вызов DllMain

**Реализация:**
```cpp
void __stdcall Shellcode(MANUAL_MAPPING_DATA* pData) {
    if (!pData) return;
    
    BYTE* pBase = pData->pbase;
    IMAGE_OPTIONAL_HEADER* pOpt = /* получение из PE заголовков */;
    
    // 1. Релокации
    if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size) {
        IMAGE_BASE_RELOCATION* pReloc = /* ... */;
        while (pReloc->SizeOfBlock) {
            // Применение релокаций
            // Корректировка адресов относительно нового базового адреса
        }
    }
    
    // 2. Разрешение импортов
    if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
        IMAGE_IMPORT_DESCRIPTOR* pImport = /* ... */;
        while (pImport->Name) {
            HMODULE hDll = pData->pLoadLibraryA(/* имя DLL */);
            // Разрешение функций
            pData->pGetProcAddress(hDll, /* имя функции */);
        }
    }
    
    // 3. TLS callbacks
    if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS].Size) {
        IMAGE_TLS_DIRECTORY* pTLS = /* ... */;
        // Вызов TLS callbacks
    }
    
    // 4. Exception handlers (SEH)
    if (pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size) {
        pData->pRtlAddFunctionTable(/* ... */);
    }
    
    // 5. Вызов DllMain
    f_DLL_ENTRY_POINT _DllMain = (f_DLL_ENTRY_POINT)(pBase + pOpt->AddressOfEntryPoint);
    pData->hMod = (_DllMain)((HINSTANCE)pBase, DLL_PROCESS_ATTACH, NULL) ? 
                  (HMODULE)pBase : NULL;
}
```

#### 1.4. Оптимизация для слабых ПК

**Изменения:**
- Размер чанков уменьшен с 8KB до 4KB
- Добавлена задержка 1ms каждые 5 чанков
- Постепенная запись секций для снижения нагрузки

**Реализация:**
```cpp
const SIZE_T STAGED_CHUNK_SIZE = 0x1000; // 4KB chunks
while (totalWritten < sectionSize) {
    SIZE_T chunkSize = min(STAGED_CHUNK_SIZE, sectionSize - totalWritten);
    
    // Задержка каждые 5 чанков
    if (chunkCount > 0 && chunkCount % 5 == 0) {
        Sleep(1);
    }
    
    WriteProcessMemory(hProc, dst + totalWritten, src + totalWritten, 
                      chunkSize, &written);
    totalWritten += written;
    chunkCount++;
}
```

### 2. Inject From Memory (для зашифрованных DLL)

#### 2.1. Принцип работы

Аналогичен Manual Map V2, но DLL загружается из памяти (уже расшифрованная).

**Использование:**
- Когда DLL зашифрована на диске
- Когда DLL загружается из сети
- Когда нужно избежать записи на диск

**Процесс:**
1. Расшифровка DLL в памяти
2. Использование Manual Map V2 с данными из памяти
3. Остальные этапы идентичны

### 3. LoadLibrary инжект (резервный метод)

#### 3.1. Принцип работы

Классический метод через `LoadLibraryA` и `CreateRemoteThread`.

**Использование:**
- Резервный метод если Manual Map не работает
- Для совместимости со старыми системами
- Для отладки

**Недостатки:**
- Виден в PEB
- Обнаруживается антивирусами
- Оставляет следы в системе

---

## АНТИДАМП ЗАЩИТА

### 1. Многоуровневая защита

#### Уровень 1: Инъекция опкодов

**Опкоды:**
- `0x0F 1A` - недокументированная инструкция
- `0x0F 1B` - недокументированная инструкция

**Размещение:**
- В начале критичных функций
- В секциях кода
- В точках входа

#### Уровень 2: Защита секций

**Методы:**
- Шифрование секций в памяти
- Обфускация данных
- Защита от чтения памяти

#### Уровень 3: Проверка целостности

**Проверки:**
- Контрольные суммы секций
- Верификация кода
- Обнаружение патчей

#### Уровень 4: Рассеивание кода

**Принцип:**
- Разбиение кода на фрагменты
- Размещение в разных местах
- Динамическая сборка

### 2. Защита во время инжекта

#### 2.1. Стирание заголовков PE

**Механизм:**
После успешного инжекта заголовки PE стираются из памяти:

```cpp
// 5 проходов с разными паттернами
for (int pass = 0; pass < 5; pass++) {
    BYTE pattern = /* 0x00, 0xFF, 0xAA, 0x55 */;
    WriteProcessMemory(hProc, pTargetBase, emptyBuffer, 0x1000, &erased);
}
```

**Результат:**
- Невозможность анализа PE структуры
- Защита от дампа заголовков
- Усложнение реверс-инжиниринга

#### 2.2. Стирание shellcode

**Механизм:**
Shellcode стирается сразу после использования:

```cpp
WriteProcessMemory(hProc, pShellcode, emptyBuffer, shellcodeSize, &erased);
```

#### 2.3. Стирание entry point

**Механизм:**
Первые 64 байта entry point стираются:

```cpp
BYTE* entryPoint = pTargetBase + pNtHeader->OptionalHeader.AddressOfEntryPoint;
WriteProcessMemory(hProc, entryPoint, emptyBuffer, 64, &erased);
```

**Результат:**
- Невозможность анализа точки входа
- Защита от статического анализа
- Усложнение отладки

#### 2.4. Стирание mapping data

**Механизм:**
Структура `MANUAL_MAPPING_DATA` стирается:

```cpp
WriteProcessMemory(hProc, MappingDataAlloc, emptyBuffer, 
                  sizeof(MANUAL_MAPPING_DATA), &erased);
```

### 3. Защита памяти процесса

#### 3.1. Установка прав доступа

**После инжекта:**
- Секции получают минимальные необходимые права
- `.text` → `PAGE_EXECUTE_READ`
- `.data` → `PAGE_READWRITE`
- `.rdata` → `PAGE_READONLY`

**Реализация:**
```cpp
for (UINT i = 0; i < numberOfSections; i++) {
    DWORD protection = PAGE_READONLY;
    if (section->Characteristics & IMAGE_SCN_MEM_WRITE)
        protection = PAGE_READWRITE;
    else if (section->Characteristics & IMAGE_SCN_MEM_EXECUTE)
        protection = PAGE_EXECUTE_READ;
    
    VirtualProtectEx(hProc, pTargetBase + section->VirtualAddress,
                    section->Misc.VirtualSize, protection, &old);
}
```

---

## ЗАЩИТА ENTRY POINT

### 1. Обфускация DllMain

#### 1.1. Переименование функции

**Механизм:**
- Оригинальная функция: `DllMain_Protected`
- Экспорт: `DllMain` (для совместимости)

**Преимущества:**
- Усложняет поиск в дампе
- Защита от статического анализа
- Обфускация точки входа

#### 1.2. Арифметическая обфускация

**Реализация:**
```cpp
volatile DWORD dummy = (DWORD)hModule ^ 0xDEADBEEF;
dummy = dummy * 0x12345678;
```

**Назначение:**
- Защита от анализа компилятором
- Обфускация операций
- Усложнение реверс-инжиниринга

#### 1.3. Отключение оптимизации

**Директивы:**
```cpp
#pragma optimize("", off)
#pragma runtime_checks("", off)
```

**Назначение:**
- Сохранение структуры кода
- Защита от оптимизаций компилятора
- Упрощение анализа

### 2. Минимальная инициализация

#### 2.1. Безопасные операции

**В DllMain разрешено:**
- Сохранение handle модуля
- Отключение уведомлений потоков
- Создание потока инициализации

#### 2.2. Запрещенные операции

**В DllMain запрещено:**
- Работа с реестром
- Файловые операции
- Сетевые запросы
- Сложные проверки безопасности
- Вызовы антидамп функций

**Причина:**
- Избежание дедлоков
- Предотвращение крашей
- Соответствие best practices

### 3. Асинхронная инициализация

#### 3.1. Создание потока

**Механизм:**
```cpp
HANDLE hThread = CreateThread(NULL, 0, Initialize, NULL, 0, NULL);
CloseHandle(hThread); // Не ждем завершения
```

**Преимущества:**
- Быстрый возврат из DllMain
- Избежание блокировок
- Безопасная инициализация

#### 3.2. Функция Initialize

**Выполняет:**
- Все проверки безопасности
- Инициализацию антидамп защиты
- Проверку токена
- Проверку HWID
- Инициализацию Firebase
- Создание overlay окна

---

## СИСТЕМА БЕЗОПАСНОСТИ

### 1. Многоуровневые проверки

#### 1.1. Уровни безопасности

**SECURITY_QUICK:**
- Проверка отладчика
- Проверка процессов
- Проверка трафика

**SECURITY_MEDIUM:**
- Все из QUICK
- Проверка API хуков
- Проверка сетевых мониторов

**SECURITY_FULL:**
- Все из MEDIUM
- Полная проверка системы
- Проверка виртуальных машин

**SECURITY_EXTREME:**
- Все из FULL
- Критичные проверки
- Немедленный выход при нарушении

#### 1.2. Точки проверки

**Перед операциями:**
- `securityBeforeDB()` - перед работой с БД
- `securityBeforeUI()` - перед UI операциями
- `securityBeforeInject()` - перед инжектом
- `securityDuringInject()` - во время инжекта

**Реализация:**
```cpp
namespace Security {
    bool check(SecurityLevel level, const std::string& stage);
    bool beforeDB(const std::string& operation);
    bool beforeUI(const std::string& operation);
    bool beforeInject(const std::string& operation);
    bool duringInject(const std::string& operation);
}
```

### 2. Антипатч защита

#### 2.1. Обнаружение патчей

**Проверки:**
- Проверка целостности кода
- Обнаружение модификаций памяти
- Проверка критичных функций

#### 2.2. Блокировка инструментов

**Блокируемые процессы:**
- Отладчики (x64dbg, OllyDbg, WinDbg)
- Анализаторы (IDA Pro, Ghidra, Binary Ninja)
- Снифферы (Wireshark, Fiddler)
- Мониторы процессов (Process Monitor, Process Hacker)

**Реализация:**
```cpp
namespace AntiPatch {
    bool checkDebugger();
    bool checkAnalysisTools();
    bool checkNetworkMonitors();
    bool checkProcessMonitors();
}
```

### 3. BSOD защита

#### 3.1. Принцип работы

При обнаружении критичных нарушений безопасности вызывается BSOD (Blue Screen of Death).

**Использование:**
- Критичные нарушения безопасности
- Обнаружение виртуальной машины
- Обнаружение отладчика в критичный момент

**Реализация:**
```cpp
namespace BSOD {
    void trigger();
    void triggerWithMessage(const std::string& message);
}
```

### 4. Проверка HWID

#### 4.1. Генерация HWID

**Компоненты:**
- CPU ID
- Serial Number материнской платы
- MAC адрес
- Volume Serial Number
- Windows ID

**Алгоритм:**
```cpp
std::string HWID = 
    getCPUID() + 
    getMotherboardSerial() + 
    getMACAddress() + 
    getVolumeSerial() + 
    getWindowsID();
    
std::string hash = SHA256(HWID);
```

#### 4.2. Валидация HWID

**Проверки:**
- Сравнение с сохраненным HWID
- Проверка изменений компонентов
- Обнаружение клонирования

**При несоответствии:**
- Заморозка процесса
- MessageBox с ошибкой
- Краш процесса

### 5. Проверка токена

#### 5.1. Структура токена

**Компоненты:**
- Username (зашифрован)
- HWID (зашифрован)
- Timestamp
- Подпись (HMAC)

#### 5.2. Валидация

**Проверки:**
1. Формат токена
2. Подпись
3. Срок действия
4. HWID соответствие
5. Whitelist проверка
6. Ban проверка

**При ошибке:**
- `SecureCrash()` - заморозка → MessageBox → краш

### 6. Live проверки безопасности

#### 6.1. Фоновый мониторинг

**Проверки каждые 3 секунды:**
- Проверка отладчика
- Проверка процессов
- Проверка HWID
- Проверка токена
- Проверка whitelist
- Проверка бана
- Проверка maintenance

**Реализация:**
```cpp
void StartSecurityChecks(const std::string& username) {
    std::thread([username]() {
        while (true) {
            // Проверки безопасности
            if (/* нарушение */) {
                SecureCrash("Security violation detected");
            }
            std::this_thread::sleep_for(std::chrono::seconds(3));
        }
    }).detach();
}
```

---

## ШИФРОВАНИЕ И ОБФУСКАЦИЯ

### 1. Шифрование DLL

#### 1.1. Алгоритм шифрования

**Использование:**
- AES-256 для основного шифрования
- Дополнительное XOR шифрование
- Ключ генерируется из HWID

**Процесс:**
1. Генерация ключа из HWID
2. Шифрование DLL AES-256
3. Дополнительное XOR шифрование
4. Сохранение в `.tmp` файл

#### 1.2. Расшифровка

**Процесс:**
1. Чтение зашифрованного файла
2. Генерация ключа из HWID
3. Расшифровка XOR
4. Расшифровка AES-256
5. Инжект из памяти

**Реализация:**
```cpp
namespace DllEncryptor {
    bool encrypt(const std::string& inputPath, const std::string& outputPath);
    std::vector<BYTE> decrypt(const std::string& encryptedPath);
}
```

### 2. Обфускация строк

#### 2.1. XOR шифрование

**Принцип:**
- Все строки шифруются XOR
- Ключ уникален для каждой строки
- Расшифровка при использовании

**Реализация:**
```cpp
namespace StringXor {
    std::string decrypt(const std::string& encrypted, int key);
    std::string encrypt(const std::string& plain, int key);
}
```

### 3. Шифрование трафика

#### 3.1. Обфускация URL

**Механизм:**
- URL обфусцируются перед отправкой
- Динамическая генерация путей
- Защита от анализа трафика

#### 3.2. Шифрование данных

**Механизм:**
- Данные шифруются перед отправкой
- Использование AES-256
- Динамические ключи

---

## СЕТЕВАЯ БЕЗОПАСНОСТЬ

### 1. Интеграция с Firebase

#### 1.1. Авторизация

**Процесс:**
1. Получение токена от пользователя
2. Валидация токена
3. Проверка HWID
4. Проверка whitelist
5. Проверка бана

#### 1.2. Проверки

**Whitelist:**
- Проверка наличия пользователя в whitelist
- Проверка роли пользователя
- Проверка доступа к продукту

**Ban:**
- Проверка статуса бана
- Проверка причины бана
- Проверка срока бана

**Maintenance:**
- Проверка режима обслуживания
- Блокировка при maintenance

### 2. Защита трафика

#### 2.1. Обфускация URL

**Механизм:**
- Динамическая генерация путей
- Обфускация параметров
- Защита от анализа

#### 2.2. Шифрование данных

**Механизм:**
- Шифрование запросов
- Шифрование ответов
- Динамические ключи

---

## ОПТИМИЗАЦИЯ И ПРОИЗВОДИТЕЛЬНОСТЬ

### 1. Оптимизация инжекта

#### 1.1. Для слабых ПК

**Изменения:**
- Размер чанков: 8KB → 4KB
- Задержка 1ms каждые 5 чанков
- Постепенная запись секций

#### 1.2. Для всех ПК

**Оптимизации:**
- Кеширование handles
- Минимизация вызовов API
- Эффективное использование памяти

### 2. Оптимизация компиляции

#### 2.1. Release конфигурация

**Настройки:**
- `Optimization: MaxSpeed`
- `InlineFunctionExpansion: AnySuitable`
- `FavorSizeOrSpeed: Speed`
- `OmitFramePointers: true`
- `LinkTimeCodeGeneration: UseLinkTimeCodeGeneration`
- `OptimizeReferences: true`
- `EnableCOMDATFolding: true`

**Отключено:**
- `BufferSecurityCheck: false`
- `ControlFlowGuard: false`
- `GenerateDebugInformation: false` (в Release)

---

## СОВМЕСТИМОСТЬ С VMPROTECT

### 1. Что будет работать

#### 1.1. Manual Map инжект

**Совместимость:**
- ✅ VMProtect сохраняет валидную PE структуру
- ✅ Релокации обрабатываются корректно
- ✅ Импорты разрешаются правильно
- ✅ Базовые проверки PE проходят

#### 1.2. Entry Point

**Важно:**
- VMProtect может изменить `AddressOfEntryPoint` на свой виртуальный код
- Но обычно он все равно вызывает оригинальный DllMain
- Инжект должен работать, но может потребоваться тестирование

### 2. Потенциальные проблемы

#### 2.1. Конфликты защиты

**Проблемы:**
- VMProtect защита памяти может конфликтовать с нашей антидамп защитой
- Дополнительные секции VMProtect могут влиять на обработку
- Виртуализация кода может усложнить отладку

#### 2.2. Рекомендации

**Настройки VMProtect:**
- ✅ Включить защиту памяти
- ✅ Включить виртуализацию
- ⚠️ Осторожно с защитой импортов (может конфликтовать)
- ⚠️ Осторожно с защитой релокаций (может конфликтовать)

**Тестирование:**
- Обязательно протестировать инжект после защиты VMProtect
- Проверить работу всех функций DLL
- Убедиться что антидамп защита работает

### 3. Порядок защиты

**Рекомендуемый порядок:**
1. Компиляция проекта в Release
2. Защита DLL через VMProtect
3. Шифрование защищенной DLL (опционально)
4. Тестирование инжекта

---

## ОБРАБОТКА ОШИБОК И КРАШОВ

### 1. SecureCrash механизм

#### 1.1. Процесс краша

**Этапы:**
1. **Заморозка процесса:**
   ```cpp
   FreezeProcess(); // Блокировка всех потоков
   ```

2. **Задержка 500ms:**
   ```cpp
   Sleep(500); // Даем время для полной заморозки
   ```

3. **MessageBox с ошибкой:**
   ```cpp
   MessageBoxA(NULL, message, "Security Violation", MB_OK | MB_ICONERROR);
   ```

4. **Краш процесса:**
   ```cpp
   CrashProcess(); // ExitProcess или TerminateProcess
   ```

#### 1.2. Заморозка процесса

**Механизм:**
- Использование `SuspendThread` для всех потоков
- Множественные вызовы для надежности
- Использование `NtSuspendThread` как дополнительный метод

**Реализация:**
```cpp
void FreezeProcess() {
    // Метод 1: CreateToolhelp32Snapshot
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    // Блокировка всех потоков процесса
    
    // Метод 2: NtSuspendThread (дополнительный)
    // Дополнительная блокировка через NTDLL
}
```

### 2. Обработка исключений

#### 2.1. SEH (Structured Exception Handling)

**Использование:**
- `__try/__except` блоки в критичных местах
- Обработка ACCESS_VIOLATION
- Безопасный выход при ошибках

#### 2.2. Безопасные функции

**Принцип:**
- Все критичные функции обернуты в try/catch
- Безопасная обработка исключений
- Предотвращение крашей

---

## ЗАКЛЮЧЕНИЕ

### Ключевые особенности проекта

1. **Многоуровневая защита:**
   - Антидамп защита
   - Защита entry point
   - Антипатч защита
   - Шифрование и обфускация

2. **Продвинутый инжект:**
   - Manual Map V2
   - Инжект из памяти
   - Оптимизация для слабых ПК
   - Полная очистка следов

3. **Система безопасности:**
   - Многоуровневые проверки
   - Live мониторинг
   - HWID защита
   - Токен валидация

4. **Сетевая безопасность:**
   - Интеграция с Firebase
   - Шифрование трафика
   - Обфускация URL

5. **Оптимизация:**
   - Для слабых ПК
   - Эффективное использование памяти
   - Минимизация следов

### Рекомендации

1. **Тестирование:**
   - Всегда тестировать после изменений
   - Проверять на разных системах
   - Тестировать с VMProtect

2. **Безопасность:**
   - Регулярно обновлять защиту
   - Мониторить новые методы обхода
   - Обновлять антипатч списки

3. **Производительность:**
   - Мониторить производительность инжекта
   - Оптимизировать для слабых ПК
   - Балансировать защиту и производительность

---

**Версия документации:** 1.0  
**Дата создания:** 2024  
**Автор:** SkeetInjector Development Team

---

*Эта документация описывает полную архитектуру и механизмы защиты проекта SkeetInjector. Все описанные методы и техники используются для защиты интеллектуальной собственности и предотвращения несанкционированного использования.*
